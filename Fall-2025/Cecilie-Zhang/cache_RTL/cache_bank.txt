`include "cache_types_pkg.svh";

module cache_bank (
    input logic CLK, nRST,
    //* Bank ID for the current bank
    input logic [BANKS_LEN-1:0] bank_id, // for requesting RAM
    //* A valid memory request to this bank
    input logic instr_valid, // valid single-cycle request 
    //* Incoming data from RAM
    input logic [CACHE_RW_SIZE-1:0] ram_mem_data, // data incoming from RAM
    //* Input from each MSHR_entry corresponding to each bank
    input mshr_reg mshr_entry,
    //* Memory instruction and its various fields
    input in_mem_instr mem_instr_in,
    //* Signal from RAM once it has completed its operation
    input logic ram_mem_complete, // RAM completed operation
    input logic halt, 

    //! Once there's a valid miss request in the MSHR for a bank, the entire bank is busy
    output logic cache_bank_busy, // High when MSHR in-flight
    output logic scheduler_hit,
    output logic ram_mem_REN, 
    output logic ram_mem_WEN,
    output logic [CACHE_RW_SIZE-1:0] ram_mem_store, 
    output addr_t ram_mem_addr,
    output logic [31:0] scheduler_data_out,
    output logic [UUID_SIZE-1:0] scheduler_uuid_out,
    output logic scheduler_uuid_ready, 
    output logic flushed
);

    cache_set [NUM_SETS_PER_BANK-1:0] bank, next_bank;
    logic mshr_hit, next_mshr_hit;

    // FSM
    bank_fsm_states curr_state, next_state; 
    logic [NUM_BLOCKS_LEN-1:0] count_FSM, next_count_FSM;
    logic count_flush;
    cache_frame latched_block_pull_buffer, latched_victim_eject_buffer;
    logic [NUM_BLOCKS_PER_BANK_LEN:0] flush_count, next_flush_count;
    logic [WAYS_LEN-1:0] latched_victim_way_index, victim_way_index, hit_way_index, max_way, next_flush_way, flush_way, mshr_hit_way;
    logic [BLOCK_INDEX_BIT_LEN-1:0] latched_victim_set_index, set_index, victim_set_index, next_flush_set, flush_set; 

    // LRU 
    psuedo_lru_frame [NUM_SETS_PER_BANK-1:0] tree_lru, next_tree_lru;  
    logic [TREE_BITS-1:0] _node, __node;

    //* The shift is to get rid of the indexing into the right bank and just get the set index
    assign set_index = mem_instr_in.addr.index >> BANKS_LEN;    
    assign victim_set_index = mshr_entry.block_addr.index >> BANKS_LEN; 

    always_ff @ (posedge CLK, negedge nRST) begin : sequential_update
        if (!nRST) begin 
            curr_state <= START;
            bank <= '0; 
            tree_lru <= '0; 
            count_FSM <= '0;
            latched_victim_way_index <= '0; 
            latched_victim_set_index <= '0; 
            latched_victim_eject_buffer <= '0;
            latched_block_pull_buffer <= '0;
            flush_set <= '0; 
            flush_way <= '0;
            flush_count <= '0;
            mshr_hit <= 0;
        end else begin 
            curr_state <= next_state; 
            bank <= next_bank; 
            tree_lru <= next_tree_lru;
            flush_set <= next_flush_set; 
            flush_way <= next_flush_way;
            flush_count <= next_flush_count; 
            count_FSM <= next_count_FSM; 
            mshr_hit <= next_mshr_hit;

            if (curr_state == START) begin
                //* Gets a valid MSHR entry
                if (mshr_entry.valid) begin 
                    latched_victim_set_index <= victim_set_index;
                    latched_victim_way_index <= (next_mshr_hit) ? mshr_hit_way : victim_way_index;
                    //* Save the victim cache line for writeback if it's dirty
                    latched_victim_eject_buffer <= bank[victim_set_index][victim_way_index];

                    latched_block_pull_buffer.valid <= 1'b1;
                    //* Mark the new cache line as dirty if it's a write operation or if it was a MSHR hit to an already dirty line
                    latched_block_pull_buffer.dirty <= (|mshr_entry.write_status || (mshr_hit && bank[latched_victim_set_index][latched_victim_way_index].dirty));
                    latched_block_pull_buffer.tag <= mshr_entry.block_addr.tag;
                end else begin 
                //* If the mshr entry is not valid (doesn't have a valid miss request)
                    latched_victim_set_index <= '0;
                    latched_victim_way_index <= '0;
                    latched_victim_eject_buffer <= '0;
                end 
            end else if ((curr_state == BLOCK_PULL)) begin 
                //* If the request was a write operation to the current word
                if (mshr_entry.write_status[NUM_BLOCKS_LEN'(count_FSM)]) begin 
                    latched_block_pull_buffer.block[NUM_BLOCKS_LEN'(count_FSM)] <= mshr_entry.write_block[NUM_BLOCKS_LEN'(count_FSM)];
                end else if (ram_mem_complete && !mshr_hit) begin 
                //* Data that arrives from RAM
                    latched_block_pull_buffer.block[NUM_BLOCKS_LEN'(count_FSM)] <= ram_mem_data;
                end 
            end
        end 
    end 

    always_comb begin : check_mshr_hit
        next_mshr_hit = 0;
        mshr_hit_way = 0;

        //* If the mshr entry is valid and the current state is not FINISH, check every way in the victim's way to ensure that the missed data is not in the bank
        //* This could be because the previous reqeust already request for this block of data. No need to request from memory again for this request
        //* If  it  is, set the next_mshr_hit high, and mshr_hit_way to the corresponding way
        if (mshr_entry.valid && curr_state != FINISH) begin
            for (int i = 0; i < NUM_WAYS; i++) begin
                if (mshr_entry.block_addr.tag == bank[victim_set_index][i].tag && bank[victim_set_index][i].valid) begin
                    next_mshr_hit = 1'b1;
                    mshr_hit_way = i;
                end 
            end
        end
    end

    always_comb begin : do_count_FSM
    //* Keeps count of the number of words have been processed
        next_count_FSM = count_FSM;
        if (count_flush) next_count_FSM = 0; 
        //* 1. If the ram has succesfully retrieved one word or written one word to main memory and the mshr did not hit 
        //* 2. If the mshr hits?
        //* 3. 
        else if (((ram_mem_complete && !mshr_hit) || mshr_hit || ((mshr_entry.write_status[count_FSM] && (count_FSM != (BLOCK_SIZE - 1)))))) next_count_FSM = count_FSM + 1; 
    end

    //* Tree-based LRU update
    //* Maintain a binary tree using NUM_WAYS-1 bits. if bit is 0 (go left), if bit is 1 (go right). When a way is accessed, update the pointers to point away from the path just taken
    always_comb begin : victim_way_index_selection
        //* Starts at the root of the tree
        __node = 0; 

        //* Traverse down the tree WAYS_LEN determine the depth of the tree
        for (int level = 0; level < WAYS_LEN; level++) begin
            if (tree_lru[victim_set_index].tree[__node] == 0) begin
                //* If the bit points to the left
                victim_way_index[WAYS_LEN-1 - level] = 0; 
                //* Move down the tree to the left
                __node = 2 * __node + 1;
            end else begin
                //* If the bit points to the right
                victim_way_index[WAYS_LEN-1 - level] = 1;
                //* Move down the tree to the right
                __node = 2 * __node + 2;
            end
        end
    end 

    always_comb begin : tree_based_lru_update
        next_tree_lru = tree_lru;
        //* Start from the root
        _node = 0; 

        //* When a cache hits 
        if (scheduler_hit) begin
            for (int level = 0; level < WAYS_LEN; level++) begin
                //* Flip the pointer bit so that it points away form the MRU to the LRU
                next_tree_lru[set_index].tree[_node] = ~hit_way_index[(WAYS_LEN-1) - level];

                //* If current pointer points to 0, go down-left in the tree
                if (!hit_way_index[(WAYS_LEN-1) - level]) _node = (2 * _node) + 1; 
                //* If the current pointer points to 1, go down-right in the tree
                else _node = (2 * _node) + 2;
            end
        end
        //* When a miss has completed and data has been received from main memory
        else if (curr_state == FINISH) begin
            for (int level = 0; level < WAYS_LEN; level++) begin
                //* Use the bit for the filled way
                next_tree_lru[latched_victim_set_index].tree[_node] = ~latched_victim_way_index[WAYS_LEN-1 - level];

                //* If current pointer points to 0, go down-left in the tree
                if (!latched_victim_way_index[WAYS_LEN-1 - level]) _node = (2 * _node) + 1;
                //* If the current pointer points to 1, go down-right in the tree
                else _node = (2 * _node) + 2;
            end
        end
    end

    always_comb begin : cache_controller_logic
        //* Default outputs
        count_flush = 1'b0; 
        scheduler_uuid_out = '0; 
        ram_mem_REN = 1'b0; 
        ram_mem_WEN = 1'b0; 
        ram_mem_store = '0; 
        ram_mem_addr = '0; 
        next_bank = bank; 
        scheduler_hit = 1'b0; 
        scheduler_data_out = '0;
        hit_way_index = '0; 
        scheduler_uuid_ready = 0;
        cache_bank_busy = 0;
        next_flush_set = flush_set; 
        next_flush_count = flush_count;
        next_flush_set = flush_set; 
        next_flush_way = flush_way;

        //* PROCESSING A CACHE HIT
        if (instr_valid) begin
            for (int i = 0; i < NUM_WAYS; i++) begin 
                //* !scheduler_hit ensures that it only processes the first match
                if (!scheduler_hit) begin 
                    //* The data is valid and the tag matches
                    if (bank[set_index][i].valid && (bank[set_index][i].tag == mem_instr_in.addr.tag)) begin
                        if (mem_instr_in.rw_mode) begin
                            //* Starts writing the data to the specificed block and mark it as dirty
                            next_bank[set_index][i].block[mem_instr_in.addr.block_offset] = mem_instr_in.store_value;
                            next_bank[set_index][i].dirty = 1;
                        end else begin
                            //* If it's a read, the data is sent out through the scheduler_data_out line
                            scheduler_data_out = bank[set_index][i].block[mem_instr_in.addr.block_offset];
                        end
                        //* Mark it as hit in the cache
                        scheduler_hit = 1'b1;
                        //* Note down the way where the request hit for LRU calculation
                        hit_way_index = WAYS_LEN'(i);
                    end
                end
            end 
        end 

        //* Output logic for each state
        case (curr_state) 
            START: begin 
                //* Restarts the counter from 0
                count_flush = 1; 
                //* If the MSHR has a valid miss request, set the victim data to invalid and set the corresponding bank to busy
                if (mshr_entry.valid) begin 
                    next_bank[victim_set_index][victim_way_index].valid = 1'b0;
                    cache_bank_busy = 1; 
                end
            end 
            BLOCK_PULL: begin 
                //* Set the cache bank to busy
                cache_bank_busy = 1; 

                //* Is MSHR didn't hit, and it's not a write request to a block, assert ram_mem_REN
                ram_mem_REN = !mshr_hit && !mshr_entry.write_status[NUM_BLOCKS_LEN'(count_FSM)];
                ram_mem_addr = addr_t'{mshr_entry.block_addr.tag, latched_victim_set_index, BLOCK_OFF_BIT_LEN'(count_FSM), BYTE_OFF_BIT_LEN'('0)};
            end 
            VICTIM_EJECT: begin 
                //* Set the cache bank to busy
                cache_bank_busy = 1; 

                //* Write the dirty data to RAM
                ram_mem_WEN = 1'b1; 
                ram_mem_addr = addr_t'{latched_victim_eject_buffer.tag, latched_victim_set_index, NUM_BLOCKS_LEN'(count_FSM), BYTE_OFF_BIT_LEN'('0)};
                ram_mem_store = latched_victim_eject_buffer.block[count_FSM];
            end
            FINISH: begin 
                //* The cache bank is no longer busy
                cache_bank_busy = 0;
                //* Replace the old victim data with the new data from RAM
                next_bank[latched_victim_set_index][latched_victim_way_index] = latched_block_pull_buffer; 
                //* Send out the UUID for that request and signal that the data is now in the cache
                scheduler_uuid_out = mshr_entry.uuid;   
                scheduler_uuid_ready = 1;
            end
            FLUSH: begin 
                if (next_state != WRITEBACK) begin 
                    next_flush_set = NUM_SETS_PER_BANK_LEN'(flush_count);
                    //* Way 0, set 0 to NUM_SETS_PER_BANK --> Way 1, set 0 to NUM_SETS_PER_BANK, ...
                    if (flush_set == (NUM_SETS_PER_BANK - 1)) next_flush_way = flush_way + 1; 
                    //* If the data is not dirty, increment the flush counter
                    if (!bank[flush_set][flush_way].dirty) next_flush_count = flush_count + 1; 
                end 
            end 
            WRITEBACK: begin 
                ram_mem_WEN = 1'b1; 
                ram_mem_addr = addr_t'{bank[next_flush_set][next_flush_way].tag, next_flush_set, NUM_BLOCKS_LEN'(count_FSM), BYTE_OFF_BIT_LEN'('0)};
                ram_mem_store = bank[next_flush_set][next_flush_way].block[NUM_BLOCKS_LEN'(count_FSM)];

                //* Once RAM has finished its transaction and all the block has been written back, set the dirty, valid and block bits to 0
                if (ram_mem_complete) begin 
                    if (count_FSM == NUM_BLOCKS_LEN'(BLOCK_SIZE - 1)) begin 
                        count_flush = 1'b1; 
                        next_bank[next_flush_set][next_flush_way].dirty = 1'b0;
                        next_bank[next_flush_set][next_flush_way].valid = 1'b0;
                        next_bank[next_flush_set][next_flush_way].block = '0;
                    end  
                end 
        
            end
            //* In HALT state, assert flushed to be high
            HALT: flushed = 1; 
        endcase
    end 

    //* Next state logic
    always_comb begin : fsm_state_logic
        next_state = curr_state; 
        case (curr_state) 
            START: begin 
                //* If the MSHR has a valid miss request, the next state is BLOCK_PULL
                if (mshr_entry.valid) next_state = BLOCK_PULL;
                //* If the halt isserted, next state is FLUSH
                else if (halt) next_state = FLUSH; 
            end 
            //* If a cache line of data has been received from RAM, if the victim line is dirty, go to VICTIM_EJECT, otherwise, go to FINISH
            BLOCK_PULL:  if ((count_FSM == (BLOCK_SIZE - 1)) && (next_count_FSM == 0)) next_state = (bank[latched_victim_set_index][latched_victim_way_index].dirty && !mshr_hit) ? VICTIM_EJECT : FINISH;  
            //* If all the data has been written back RAM, the next state is FINISH
            VICTIM_EJECT: if (count_FSM == (BLOCK_SIZE - 1) && (next_count_FSM == 0)) next_state = FINISH; 
            //* In FINISH state, the next state is always going to be START
            FINISH: next_state = START; 
            FLUSH: begin 
                //* If all the blocks in the bank have been flushed, next state is HALT
                if (flush_count == (NUM_BLOCKS_PER_BANK + 1)) next_state = HALT;
                //* If a specific data in the bank is dirty, next state is to write back the data to the RAM
                else if (bank[flush_set][flush_way].dirty) next_state = WRITEBACK;
            end
            //* If all the data has been written back to the RAM, next state return back to FLUSH
            WRITEBACK: if (count_FSM == (BLOCK_SIZE - 1) && (next_count_FSM == 0)) next_state = FLUSH; 
            HALT: next_state = START; 
        endcase
    end 

endmodule